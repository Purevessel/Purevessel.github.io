
#C PrimerPlus#
p103 修饰精度

p109 参数传递是否就是格式化字符串漏洞原理？

p114 scanf()的一些异常处理

p384 argv参数

p393 存储类别(未细读

p423 const修饰指针位置的区分

p590

《C语言程序设计》K&R版 《UNIX网络编程》《UNIX环境高级编程》《深入Linux内核架构》《Linux内核设计与实现》

#C陷阱与缺陷#
单引号括起的一个字符代表一个整数，而双引号代表一个指针

注意位运算符的优先性，它的优先性低于大多数运算符，一起使用的时候注意括号的添加

对于边界的处理：通过枚举特例和仔细边界计算

匈牙利命名方式，即在变量名前加入前缀，前缀为变量名类型的简写

采用(常量 == 变量)来避免出现写成赋值符号‘=’的错误

free后需立即将指针置空

.cfg文件

https://blog.csdn.net/weixin_38391755/article/details/80380786 makefile


#C++#
原生C/C++
(void)(&_x == &_y)由于无法typeof(x)==typeof(y) 判断他们2个的地址指针是否相等（显然不等），如果_x和_y的类型不一样，其指针类型也会不一样，2个不一样的指针类型进行比较操作，会抛出一个编译警告。

new/malloc/delete/free  static const与define(inline)

memcpy和memove https://blog.csdn.net/li_ning_/article/details/51418400

内存结构(从高到低) 栈区(从高到低增长)->堆区(从低往高增长)->未初始化全局变量(bss段)->已初始化全局变量，静态，常量(数据段)->可执行代码(代码段)

预编译：预编译阶段仅仅对源代码的单词进行变换 https://blog.csdn.net/rl529014/article/details/51613941

重入和不可重入
这种情况出现在多任务系统当中，在任务执行期间捕捉到信号 并对其进行处理时，进程正在执行的指令序列就被信号处理程序临时中断 。如果从信号处理程序返回，则继续执行进程断点处的正常指令序列，从重新恢复到断点重新执行的过程中，函数所依赖的环境没有发生改变，就说这个函数是 可重入的，反之就是不可重入的。

满足下面条件之一的多数是不可重入函数：

(1)使用了静态数据结构;

(2)调用了malloc或free;

(3)调用了标准I/O函数;标准io库很多实现都以不可重入的方式使用全局数据结构。

(4)进行了浮点运算.许多的处理器/编译器中，浮点一般都是不可重入的 (浮点运算大多使用协处理器或者软件模拟来实现。

引用与指针 引用就是某个目标变量的“别名”(alias)，引用本身不占存储单元，系统也不给引用分配存储单元。不能建立数组的引用。

引用作为函数返回值的优劣：因为不产生返回值的副本，节省空间。劣势 effective C++ 23/30/31 

引用的对象不能改变，指针的对象可以改变。

引用无空引用，必须初始化，而指针可以为空

函数指针与套娃问题 size *(*func)(intaillist) https://www.cnblogs.com/yjd_hycf_space/p/7495640.html

cast转换 智能指针 https://www.cnblogs.com/MengX/p/12323617.html

shared_ptr的问题：互相指向导致循环引用，由于计数不为0，导致空间都不会释放。实际可能出现业务：链表

shared_ptr手动实现

右值引用 https://blog.csdn.net/dongkai0918/article/details/101171736

lambda表达式  https://blog.csdn.net/csdnnews/article/details/103331618

多态：虚函数 纯虚函数 析构函数是否需要成为虚函数  

每一个类都有一个指向内部虚表地址的指针，且vptr位于对象最前端。当没有virtual重写时，内部的函数指针指向同一个函数。有的时候，指向新的函数

而多继承下，子类的虚函数表首先是按继承顺序来的，其次，针对重载的同一父亲的函数，采取thunk这种偏移技术，使得this指针偏移合理的值从而调用合理的函数，表现在VS的adjustor中。

虚函数表 https://www.cnblogs.com/hushpa/p/5707475.html

虚函数表的生成时间   https://www.cnblogs.com/tsecer/p/10487453.html

重载与覆盖：前者指同名函数，参数不同或返回类型不同的调用，后者指虚函数的多态。前者为静态编译，后者为动态

RTTI https://blog.csdn.net/ljianhui/article/details/46487951
auto的实现机制 https://www.zhihu.com/question/294048058


STL容器 各种底层实现

vector 连续空间 2倍容量增长，容量满以后重新分配空间。因此，对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了。heap和priority_queue基于它

deque 使用密集的被称作map的一块内存来存储指针，每个指针指向另一段连续线性空间，称为缓冲区 stack和queue基于它

list 双向链表实现

set 红黑树 默认升序

multiset 红黑树 允许重复键值对插入

map mulitimap 平衡二叉树

allocator 定位：空间配置器 为了解决内存碎片，分为两级配置，大于128bytes下直接用malloc/free，小于的情况用指针数组解决，有点类似map，每个指向不同内存规格的区块 https://blog.csdn.net/xy913741894/article/details/66974004

泛型编程

编译器对函数模板进行了两次编译
第一次编译时,首先去检查函数模板本身有没有语法错误
第二次编译时,会去找调用函数模板的代码,然后通过代码的真正参数,来生成真正的函数。


#Linux/os#
https://blog.nowcoder.net/n/ef1138359b5e49b4a3763947f2cdf879 大纲
体系结构：用户态/内核态
系统调用：内核的访问接口
公用函数库+shell

常用命令及相关参数 
rwx针对文件和目录的设计权限是不同的，特别是针对没有x权限的用户，文件是无法执行，而目录是无法进入

grep sed和awk https://www.cnblogs.com/itzhao/p/11253883.html

进程间的通信方式：管道/消息队列/信号量/套接字/内存共享

7个不同的运行级别

FHS (Linux目录配置标准) p224

系统日志文件 https://blog.csdn.net/c_abua/article/details/81254328

bios和uefi：不同的加载核心文件程序 p91

LILO和GRUB:都是引导加载程序，用于引导操作系统的读写，由于bios访问数据较少，所以分两个阶段读写，第一个阶段通过ipl查询分区表来加载数据，第二部分就是通过上述的两者来加载程序更需要磁盘空间的部分。

文件系统：https://www.cnblogs.com/aaronLinux/p/5744597.html
采用索引结构，结构为：目录项(文件名和Indoe节点)->Inode(文件基本信息和数据块指针)->数据块

fork()与线程

I/O多路复用 select/poll/epoll  https://www.cnblogs.com/aspirant/p/9166944.html

#web#

A 类：前 8 位表示网络 ID，后 24 位表示主机 ID；该地址分配给政府机关单位使用。

B 类：前 16 位表示网络 ID，后 16 位表示主机 ID；该地址分配给中等规模的企业使用。

C 类：前 24 位表示网络 ID，后 8 位表示主机 ID；该地址分配给任何需要的人使用

1) A类地址
私有地址范围为 10.0.0.0～10.255.255.255。127.0.0.0～127.255.255.255。

2) B类地址
私有地址范围为 172.16.0.0～172.31.255.255。169.254.X.X。

3) C类地址
私有地址范围为 192.168.0.0～192.168.255.255。

物理层： （中继器，集线器） 

数据链路： （网桥，交换机） 

网络层：（路由器） 

传输层： (网关)

路由器的基本功能如下：

第一，网络互连：路由器支持各种局域网和广域网接口，主要用于互连局域网和广域网，实现不同网络互相通信；

第二，数据处理：提供包括分组过滤、分组转发、优先级、复用、加密、压缩和防火墙等功能；

第三，网络管理：路由器提供包括路由器配置管理、性能管理、容错管理和流量控制等功能。

传输层

TCP/UDP基本区别

https://blog.csdn.net/qq_36254699/article/details/90604315

三次握手 客户端发送 SYN=1,seq=x，服务端回复seq=y，ack=x+1，SYN=1，ACK=1 客户端回复ACK=1，SEQ=x+1，ack=y+1

四次挥手 客户端发送FIn=1，seq=u  服务器确认，ACK=1，ack=u+1，seq=v

MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间

滑动窗口与阻塞控制 https://blog.csdn.net/u014454538/article/details/96450351

close_wait状态与TCP各种状态转换 https://blog.csdn.net/bianchengxiaosheng/article/details/78750237
https://blog.csdn.net/wk_bjut_edu_cn/article/details/82343939

应用层

1)OPTIONS 返回服务器针对特定资源所支持的HTML请求方法 或web服务器发送测试服务器功能（允许
客户端查看服务器性能）

(2)GET 向特定资源发出请求（请求指定页面信息，并返回实体主体）

(3)POST 向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有
资源的修改

(4)PUT 向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档的内容）

(5)HEAD 与服务器索与get请求一致的相应，响应体不会返回，获取包含在小消息头中的原信息（与get请求
类似，返回的响应中没有具体内容，用于获取报头）

(6)DELETE 请求服务器删除request-URL所标示的资源（请求服务器删除页面）

(7)TRACE 回显服务器收到的请求，用于测试和诊断

(8)CONNECT HTTP/1.1协议中能够将连接改为管道方式的代理服务器
https://www.cnblogs.com/logsharing/p/8448446.html get/post区别
 
session,cookie,token https://www.cnblogs.com/wxinyu/p/9154178.html

状态码 https://www.cnblogs.com/xflonga/p/9368993.html

1xx 消息：请求已被服务器接收，继续处理（100~102）

2xx 成功：请求已成功被服务器接收、理解、并接受（200~208，226）

3xx 重定向：需要后续操作才能完成这一请求（300~308）

4xx 客户端请求错误：请求含有词法错误或者无法被执行（400~426，
428，429，431，444，450，451，494）

5xx 服务器错误：服务器在处理某个正确请求时发生错误（500~511）

200 OK 201 服务器依照客户端的请求创建了一个新资源

302 执行重定向 307 请求还没有被处理，因为所请求的资源不在本地：它在另一个url处

403服务器收到请求但拒绝使用 404请求失败，未找到资源

500实体主体中的文档（通用的服务器错误响应）是一个错误消息 503服务器由于临时的服务器过载或者是维护，无法解决当前的请求

https:

1. 客户端发起HTTPS请求

2. 服务端的配置
采用HTTPS协议的服务器必须要有一套数字证书，可以是自己制作或者CA证书。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，
而使用CA证书则不会弹出提示页面。这套证书其实就是一对公钥和私钥。公钥给别人加密使用，私钥给自己解密使用。
3. 传送证书
这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等。
4. 客户端解析证书
这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等，如果发现异常，
则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随机值，然后用证书对该随机值进行加密。
5. 传送加密信息
这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。
6. 服务段解密信息
服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，
这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥
7. 传输加密后的信息
这部分信息是服务段用私钥加密后的信息，可以在客户端被还原。
8. 客户端解密信息
客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容	

ftp:20端口用于传输数据。 21端口用于连接

基于TCP的有：Telnet，HTTP，HTTPS，SMTP，POP3，FTP

基于UDP的有：NFS，TFTP，SNMP，DHCP，NTP，BOOTP
SDU（Service Data Unit）服务数据单元是OSI相邻上下层与层之间交换数据的单位 协议数据单元
PDU（Protocol Data Unit）协议数据单元是OSI对等层次之间传递的数据单位

IIS服务器


#db#
大纲 https://baijiahao.baidu.com/s?id=1645822927622051468&wfr=spider&for=pc

数据库系统特点：1数据结构化2共享性高，冗余度低且易扩充3独立性高


实体完整性约束:实体完整性(Entity integrity)是指关系的主关键字不能重复也不能取“空值"。

域完整性约束

域完整性是保证数据库字段取值的合理性。ss

参照完整性约束

参照完整性(Referential Integrity)是定义建立关系之间联系的主关键字与外部关键字引用的约束条件

模式/模型（Schema）  定义：也称逻辑模式，是数据库中全体数据的逻辑结构和特征的描述，是所有用户的公共数据视图。    
① 一个数据库只有一个模式；  
② 是数据库数据在逻辑级上的视图；  
③ 数据库模式以某一种数据模型为基础；
④ 定义模式时不仅要定义数据的逻辑结构（如数据记录由哪些数据项构成，数据项的名字、类型、取值范围等），而且要定义与数据有关的安全性、完整性要求，定义这些数据之间的联系。  
二、外模式（External Schema）  定义：也称子模式（Subschema）或用户模式，是数据库用户（包括应用程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据视图，是与某一应用有关的数据的逻辑表示。    
① 一个数据库可以有多个外模式；  
 ③ 外模式是保证数据安全性的一个有力措施。  
三、内模式（Internal Schema）  定义：也称存储模式，它是数据物理结构和存储方式的描述，是数据在数据库内部的表示方式（例如，记录的存储方式是顺序存储、按照B树结构存储还是按hash方法存储；索引按照什么方式组织；数据是否压缩存储，是否加密；数据的存储记录结构有何规定）。
① 一个数据库只有一个内模式；  
② 一个表可能由多个文件组成，如：数据文件、索引文件。  它是数据库管理系统(DBMS)对数据库中数据进行有效组织和管理的方法  
其目的有：  ① 为了减少数据冗余，实现数据共享；  ② 为了提高存取效率，改善性能。
E-R模型转换：https://blog.csdn.net/hanxuemin12345/article/details/13143755

BINARY:区分大小写

优化与基础

数据定义语言（DDL）：DROP、CREATE、ALTER 等语句。

数据操作语言（DML）：INSERT（插入）、UPDATE（修改）、DELETE（删除）语句。

数据查询语言（DQL）：SELECT 语句。

数据控制语言（DCL）: GRANT（授权的一个或多个用户执行在一个对象上的一个操作或者一组操作）、REVOKE（消除了授权，其可以是默认的授权）、COMMIT、ROLLBACK 等语句。

revoke create/select/alter/drop on table from user
回收建表/搜索/修改/删表的权限


全外连接：任意一边有值就会显示。

内连接：只返回满足连接条件的数据（两边都有的才显示）。对应等值连接。

左外连接：只要左边有值就会显示。

右外连接：只要右边有值就会显示。

当同时含有where子句、group by 子句 、having子句及聚集函数时，执行顺序如下：

--执行where子句查找符合条件的数据；

--使用group by 子句对数据进行分组；对group by 子句形成的组运行聚
集函数计算每一组的值；

--最后用having 子句去掉不符合条件的组。

--之后执行ORDER BY 排序 [ASC][DESC]

具体顺序

FROM, including JOINs

WHERE

GROUP BY

HAVING

WINDOW functions

SELECT

DISTINCT

UNION

ORDER BY

LIMIT and OFFSET


--having 子句中的每一个元素也必须出现在select列表中。有些数据库例外，如oracle.

--having子句和where子句都可以用来设定限制条件以使查询结果满足一定的条件限制。

--having子句限制的是组，而不是行。where子句中不能使用聚集函数，而having子句中可以。

使用explain sql来分析优化sql语句

DATEDIFF() 函数返回两个日期之间的时间
DATEDIFF(datepart,startdate,enddate)

第一范式（1NF）无重复的列

第二范式（2NF）属性完全依赖于主键

第三范式（3NF）属性不依赖于其它非主属性

BCNF范式

1.所有非主属性对每一个码都是完全函数依赖。

2.所有的主属性对每一个不包含它的码,也是完全函数依赖。

3.没有任何属性完全函数依赖于非码的任何一组属性。（符合3NF且主属性不互相依赖）

delete truncate drop区别
https://blog.csdn.net/qq_39390545/article/details/107144859

restrict: 确保只有不存在相关视图和 完整性约束的表才能删除

cascade: 任何相关视图和完整性约束一并被删除

https://www.cnblogs.com/wenxiaofei/p/9853682.html

存储过程(触发器是其中一类) 模块化的过程，提升执行效率，但移植性差
视图  

索引 一种排序的数据结构，用于加速插叙速度，底层结构为b，b+树/hash表。相应的，增加了存储开销和插入和删除数据的时间
主要用于经常查询的列，比如主键(唯一且不为空)，和其它表经常有连接的/需要范围查询的/需要排序的等，反之，数据少或经常修改的，不宜于建立索引

hash与b树结构的索引对比
聚合与非聚合索引 前者录的排列顺序和索引的排列顺序一致，所以查询效率快，后者指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致。

事务 事务是对数据库中一系列操作进行统一的回滚或者提交的操作

1\. 原子性（Atomicity）
事务的原子性是指事务是一个不可分割的工作单位，这组操作要么全部发生，否则全部不发生。

2\. 一致性（Consistency）
在事务开始以前，操作的数据的完整性处于一致性的状态，事务结束后，操作的数据的完整性也必须处于一致性状态。
拿银行转账来说，一致性要求事务的执行不应改变A、B 两个账户的金额总和。如果没有这种一致性要求，转账过程中就会发生钱无中生有，或者不翼而飞的现象。事务应该把数据库从一个一致性状态转换到另外一个一致性状态。

3\. 隔离性（Isolation）
事务隔离性要求系统必须保证事务不受其他并发执行的事务的影响，也即要达到这样一种效果：对于任何一对事务T1 和 T2，在事务 T1 看来，T2 要么在 T1 开始之前已经结束，要么在 T1 完成之后才开始执行。这样，每个事务都感觉不到系统中有其他事务在并发地执行。

4\. 持久性（Durability）
一个事务一旦成功提交，它对数据库的改变必须是永久的，即便是数据库发生故障也应该不回对其产生任何影响

事务的并发与隔离

1脏读 A读B数据后B回滚 

2不可重复读 A多次读B，期间B有更新 

3幻读 A修改数据后未锁表，若B新提交或者删除，会使A的改动看起来未生效

嵌套事务
子事务在父事务中的一部分称为……，父事务在进入子事务前会建立一个回滚点，当子事务回滚时，回滚到该点，而父事务回滚时，子事务会跟着回滚(因为它未提交)

引擎
InnoDB、MyISAM、MEMORY

数据库锁
锁是实现事务的关键，锁可以保证事务的完整性和并发性。

表级锁：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。

行级锁：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。

页面锁：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般

悲观锁特点:先获取锁，再进行业务操作，分为：

共享锁(S锁)又称为读锁，若事务T对A加上S锁，则事务T只能读A；其他事务只能再对A加S锁，而不能加排他锁（X锁），直到T释放A上的S锁。这就保证了其他事务可以读A，但在T释放A上的S锁之前不能对A做任何修改。

排他锁（X锁）：如果事务T对数据A加上排他锁后，则其他事务不能再对A加任任何类型的封锁。获准排他锁的事务既能读数据，又能修改数据。

乐观锁的特点：先进行业务操作，不到万不得已不去拿锁
具体情况可以从响应速度，冲突频率，重试代价等分析

1.主键约束（PRIMARY KEY）


1) 主键用于唯一地标识表中的每一条记录，可以定义一列或多列为主键。 

2) 是不可能（或很难）更新． 

3) 主键列上没有任何两行具有相同值（即重复值），不允许空（NULL）．

4) 主健可作外健，唯一索引不可；

2.唯一性约束（UNIQUE）

1) 唯一性约束用来限制不受主键约束的列上的数据的唯一性，用于作为访问某行的可选手段，一个表上可以放置多个唯一性约束．

2) 只要唯一就可以更新． 

3) 即表中任意两行在  指定列上都不允许有相同的值，允许空（NULL）．

4) 一个表上可以放置多个唯一性约束

#algorithm#
dp
求最大公约数 gcd(x,y)互余 https://blog.csdn.net/Ljnoit/article/details/99319849
stable_sort 遇到相等值不会交换

#Git#
##
[训练](https://learngitbranching.js.org/?locale=zh_CN)
##


kmp/红黑树/索引，b树和b+树 SSD和机械硬盘会影响读取效率吗/https

DELETE FROM TABLE WHERE (ID,EMAIL) IN
SELECT *
SELECT ID,EMAIL FROM PERSON WHERE
GROUP BY ID,EMAIL
HAVING COUNT(*)>1)  A
一定要建立临时表，规避既查询又更新表造成的死锁

##
#jvm#
https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html

java虚拟机：

编译(将java源码变为对应的虚拟机字节文件)——>java前端编译器转换输出class文件——>用java编译器执行字节码/JIT编译器转为机器代码后再执行

JIT编译器的虚拟机内又分为两种编译模式：一种直接转译为本地代码，另一种会进行较长的优化。一般会采用mixed的模式，即两种均采用的混合模式，可以用-Xint或者-Xcomp让所有代码都使用解释(Interpreted Mode)/编译（Compiled Mode）模式

另一种方式：AOT编译器，在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。

编译速度上，解释执行 > AOT 编译器 > JIT 编译器。

编译质量上，JIT 编译器 > AOT 编译器 > 解释执行。


文件结构：
[https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html](https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html "文件结构")

java的内存模型中，堆和方法区是共享的，但是有几项是线程私有的,exp:1.PC寄存器，用于存储当前线程执行的方法 2.虚拟机栈

JVM类加载机制

知晓了内存分布与编译转换的过程后，就需要将重点在于了解代码是如何转换并加载进内存的。从将字节码加载进内存到最后结束，大致可以分如下几步：加载->检验（可以视作静态检查，包括对规范，类型正确转换的检查）->准备->解析->初始化->运行->销毁

其中，准备和初始化的过程涉及到了对类的赋值和构造(面试常考),所以较为重要。

准备是指对JAVA中类变量(注意区分其与类成员变量的区别)的赋值，但此处赋值并非是程序员书写的赋值，而是由JAVA虚拟机赋值，比如初始化静态类变量的值地址为空:public static test = NULL，或者int类型赋为0等。但如果加入了修饰符final,表示赋值不再改变，因此会直接赋为书写的值

JAVA虚拟机并不会分辨何为构造函数的概念，它只是收集相关的赋值语句进行初始化。第一步，它会收集类变量(反复注意)和静态代码块的赋值；第二步，它会收集成员变量和普通代码块，以及最后执行的构造代码块。

触发初始化并不一定是严格按照上面的流程执行的，当有以下情况时，都会触发相关的初始化：

- new关键字实例化对象，读取/设置静态字段，调用静态方法
- 用reflect对某个类调用且该类未被初始化77
- 初始化某个类发现它的父类未初始化，需要初始化父类(注意不初始化它本身)
- 执行指定的main方法(即主类)，初始化主类
- 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。(照抄的，不懂)

## 堆空间 ##
为了保证程序运转内存的健康，了解了加载，就该了解JAVA虚拟机相关的回收机制。JAVA虚拟机有一套自己的垃圾回收机制，是基于一个很简单的思路进行的：即判断引用的计数是否变为0，相比C++运用智能指针(shared_ptr,还有用来解决循环引用的weak_ptr)，JAVA规定了GCRoot集，这个集合都是活跃的引用，只要对象的引用还有来自GCRoot的，它也必定是活跃的，这包括：

- 所有当前被加载的 Java 类
- Java 类的引用类型静态变量
- Java类的运行时常量池里的引用类型常量
- VM的一些静态数据结构里指向GC堆里的对象的引用
- 等等

标记清除算法：从名字可以看到其分为两个阶段：标记阶段和清除阶段。一种可行的实现方式是，在标记阶段，标记所有由 GC Root 触发的可达对象。此时，所有未被标记的对象就是垃圾对象。之后在清除阶段，清除所有未被标记的对象。标记清除算法最大的问题就是空间碎片问题。如果空间碎片过多，则会导致内存空间的不连续。虽说大对象也可以分配在不连续的空间中，但是效率要低于连续的内存空间。

复制算法：复制算法的核心思想是将原有的内存空间分为两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收。该算法的缺点是要将内存空间折半，极大地浪费了内存空间。

标记压缩算法：标记压缩算法可以说是标记清除算法的优化版，其同样需要经历两个阶段，分别是：标记结算、压缩阶段。在标记阶段，从 GC Root 引用集合触发去标记所有对象。在压缩阶段，其则是将所有存活的对象压缩在内存的一边，之后清理边界外的所有空间。

而JVM的回收机制专门根据了JVM的不同分区制定了不同的回收计划，老年代的分区由于使用对象使用时间长，所以直接采用复制算法回收肯定需要的空间开销极大，因此使用标记清除/标记压缩算法。而新生代分区中的对象数量较少，则可以直接使用复制算法。

JAVA的堆区是以新生代和老年代区分的，上面已经阐述过相关原则。而新生代中又有Eden区和Survivor区，Eden区占大部分内存空间的分配，因为它掌握大部分转瞬即逝的变量，时间比较长的则会送给Suvivor区。

回收类型与术语:

- minorGC 对新生代进行垃圾回收，比如Eden区分配空间满时就会触发
- majorGC 对老年代进行垃圾回收，由于往往是Eden区满后，一部分对象被回收，另一部分晋升到老年代，这时如果老年代空间也不足，就会触发majorGC。因此minorGC往往会触发majorGC
- fullGC 对所有的堆空间都进行垃圾回收，当准备要触发一次 Minor GC 时，如果发现年轻代的剩余空间比以往晋升的空间小，则不会触发 Minor GC 而是转为触发 Full GC。
- Stop-the-world ，是指在进行垃圾回收时因为标记或清理的需要，必须让所有执行任务的线程停止执行任务，从而让垃圾回收线程回收垃圾的时间间隔。在 Stop-The-World 这段时间里，所有非垃圾回收线程都无法工作，都暂停下来。只有等到垃圾回收线程工作完成才可以继续工作。

各种回收器：串行/并行/CMS/G1
 
## 1.7的永久代(Permanent Space)与1.8的元空间（MetaSpace） ##


jvm的处理场景：1.cpu长时间占用过高 2.高并发下的死锁 3.内存泄漏，gc时发现内存一直在变小