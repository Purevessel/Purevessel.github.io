#I/O底层模型#
1.最传统的I/O模型，即分为四步：客户端用户发起请求->等待系统将数据写入内核缓冲区->写入服务端用户缓冲区->发送数据回用户端。这种模式的优点在于容易实现，然而相当于必须为每一个连接分配一个独立的连接，这在高并发的场景下效率极低

2.同步非阻塞I/O(None Blocking I/O),虽然这种模型被称为NIO,但与Java的NIO(New IO)并不同，该模式需要用户不断向服务端发起请求，而服务端本身依然是：等待系统将数据写入内核缓存区->写入服务端用户缓冲区->发送数据回用户端的连续逻辑。只是客户端改为了不断轮询：

1)如果轮询的回应是仍然没有数据，则直接返回报错，等待下一轮轮询

2)如果有数据，则返回数据

这种思路下，用户端程序可以不用被堵塞，但服务端由于会收到大量内核请求，会占用大量CPU时间，导致效率下降，故也很少使用

3.I/O多路复用，相比于前两种方式，

4.异步I/O调用，客户端在发起请求后，只需要向服务端注册一个信号驱动的I/O即可，在等待服务端数据"写入-返回"这个过程中，客户端是处于非堵塞状态的，当内核完成读写，会回调客户端的接口，完成信息传递。由于异步I/O调用模型真正意义上解决了堵塞状态的问题，因此它是四种模型中吞吐量最高的。但由于底层模型实现的困难，Windows通过IOCP实现，Linux底层实现仍使用epoll实现，故在Linux上实现的异步I/O相比I/O多路复用模型并不占据优势。大多数流行框架仍然采用I/O多路复用模型

