##可扩展并行计算集群##
###计算集群的设计宗旨###
1.可扩展性：集群要求将原来的单节点转换为连接的并行节点，面对的是物理与软件方面的各种限制：包括芯片技术、冷却与电力消耗、I/O读写瓶颈等等

2.封装：集群可以分为紧凑或者分散型，前者类似机房统一管理，后者则可以分布在不同且距离较远的位置上

3.控制：采用集中或者分散的控制类别

4.同构性：集群中的节点应来自相同平台，使用相同操作系统和处理器结构，方便管理。但也有采用异构的，比如天河1号的每隔节点采用了CPU进行整型计算，GPU作为协作处理器的混合设计。

5.安全性：集群之间的通信是否开放，开放会导致外部可以访问内部集群中的任一节点，可能导致安全问题，而封闭虽然提高了安全性，相对也降低了效率

###常见集群分类###
1.计算集群：例如对天气地质的预测，主要用于对单一但计算量大的数据运算。特点是不需要进行大量的I/O操作，但对于节点之间频繁的通信要求很高。因此这些节点大多是紧耦合的

2.高可用集群：用于实现服务和容错的高可用，通过使用大量的冗余节点来保证服务的正常运行，应尽可能地消除单点故障带来的影响

3.负载均衡集群：将用户的请求分配到集群中的节点，达到高效地利用集群中的所有资源

###节点分类###
计算节点：主要用于大量并行浮点计算或者搜索

服务节点：主要用于I/O读写、服务监测、文件读写等功能

###内部连接技术###
Myrinet/Quadrics/InfiniBand(带宽最高，但也是搭建成本最高的一种)/以太网(前三者的延迟只有3-4.5μs，以太网则是他们的10倍)

###CUDA与GPU集群对于现今集群计算力的提升###
CUDA(Compute Unified Device Architecture)，由NVDIA开发，是一种GPU中的计算引擎，可以通过CUDA C相关的编程达到更高的计算需求

###单系统镜像###
单系统镜像是集群设计的一种模式，对于使用者来说，使用单系统镜像的集群就像在使用一台单独的机器，因此，该设计模式有以下特征：

单一系统：用户将整个集群视作一个多处理系统

单一控制：用户只能通过单一的接口使用服务，管理员也应该能通过单一入口配置与监控所有节点。

对称性：用户使用任一节点都能让集群正常的工作

###实现单系统镜像需要考虑问题与常见解答###
单一入口：尽管集群只暴露了一个入口给外界(比如域名)，为了解决过高流量的负载，DNS服务器在接收到请求后，会查询集群中负载最轻的节点，并将该IP返回给请求终端，让其连接到该节点上。

单文件系统：为了给用户营造出只有一个文件层次的环境，集群中的每个节点都提供了本地存储，并允许使用任意的文件操作(fopen,fwrite……)。理想的集群文件系统应该将每一个文件操作视作一个事务，完成一项就应该提交一项。同时还需要提供稳定存储(也称作全局/持久存储)，用于维护存储所有用户存储的数据，增加冗余

单一内存空间：暴露给用户的是一个大规模集中内存的假象，实际上是将各节点上分布式的总和


###冗余高可用性###
RAS：是Realiability,Availability,Serviceability（可靠性、可用性、可服务性）的简称，常用这三个维度评价系统的鲁棒性。其中可用性是最有意义的概念。

衡量可用性的计算公式：

可用性 = MTTF/MTTF+MTTR
MTTF:失效平均时间  MTTR：失效平均修复时间

其中失效又分作计划失效(公司定时维护系统等)和意外失效(系统崩溃等人为原因或者地震断电等)，其中MTTR只统计后者。作者认为这是因为不同系统对失效的时间要求不同导致的，超级计算机可以进行好几个小时的维护，但是电话系统断掉5分钟都会让人发狂。而针对集群所作的冗余，一种常见的处理是设立多个备份，并将它们互相隔离，主组件失效时换上备份。

###容错集群配置###
分为三种级别：

热备份：热备份中主要节点会负责所有有用的的工作，而备份节点只会与主要节点进行心跳信号的传递，但并不积极地进行其他的工作。

主动接管：多个节点体系结构时对称的，两个服务器都是主要的，当一个节点失效时，会将数据转移到到另一个节点，但是用户可能会遇到一些延迟和丢包的部分数据。

故障切换：一个组件失效时，该技术允许剩余系统接管之前由失效组件提供的服务。

###检查点和恢复技术###

恢复技术有两种类型，向前恢复或是向后恢复，常见的是向后恢复，即回到上一个检查点这种。这些技术的用处是提高集群系统的可用性。

##虚拟化##
 
###分类###
虚拟化以实现层次可以划分为：

指令集体系结构集（Bochs、QEMU）/硬件(VMware、Xen)/操作系统(Jail、Virtual Environment)/库(vCUDA、VisualMain Win)/应用程序(JVM、.Net)

其中以硬件和操作系统级别的虚拟化性能最高，但是其中的实现复杂度也很高，而指令级的虚拟化拥有最好的灵活性，应用程序级别的则在应用程序隔离性上表现最好。

