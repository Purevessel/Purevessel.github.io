# OCI #
容器化能提高效率，然而是以什么样的标准为方向才能够有效的提高效率？这就是OCI(Open Container Initiative)要解决的问题。

自2013年Docker的问世起，靠着Namespace和Cgroup两项核心技术实现的Docker风头正盛，凭借一己之力在容器领域上可以与微软、Google等巨头叫板，然而由于核心技术的开源，意味着有实力的大佬们完全可以自己拉起一支队伍来，比如Google的K8s，就是后来居上者，取代了Docker自身的engine，这些爱恨情仇我们先撇在一边。Docker为容器技术的提供了良好的实例，然而为了不使容器的发展由于竞争变得碎片化，提出一个统一可行的标准才是最坚实的基底，于是由Linux基金会牵头，在2015年6月的Docker大会上提出了容器标准，并成立了OCI，并发展为Linux基金会下的一个项目。Github项目上的简介我们可以看到OCI的宗旨：指明容器的配置、执行环境和生命周期，刚好对应它为此建立的两份规范：Image Format和Runtime Specification.既然有了规范这些形而上的指导,那么还需要有一个形而下的实体样例来更直观地让大家理解,因此,runc作为一个符合OCI规范的轻量级容器运行时生命周期管理工具便诞生了,它是由Docker公司开发的,并被捐献给了社区,下面,我们将通过它来一一展示OCI的规范.

OCI开篇便指出了自己的五大原则,笔者将其简单翻译并概括为:

1. 标准操作的原子化
2. 容器自身内容无关
3. 基础设施无关
4. 自动化操作
5. 工业级交付

第一条原则严格地限定容器中的每一条操作和状态,保证其的原子化."容器自身内容无关"指的是容器执行的结果始终是相同的,与容器自身具体内容是什么无关.第二与第三条分别从容器内部与外部保证了容器能在任意一个符合OCI标准的工具下运行出同样理想的结果.前三条原则的实施则为后两条原则搭上了坚实的基础,自动化操作减少了多人维护带来的冲突与困境,工业级交付则优化了整个项目的交付效率.这五条原则很好的展现出了OCI的野心:容器作为最基础的交付单元,它由一系列软件组成,在规范的操作里,这些软件可以添加,减少,更换运行顺序,然而它并不受外部环境的影响,并且它自身每次的结果都能保证是唯一而准确的.可以说这是近乎完美的工业设想.


运行周期与状态(重点)

有了良好的设想，那么就可以开始着手创建容器了。OCI规定了非常宽松的容器包结构：config.json加上容器自身的文件系统就行。在config中，OCI规定了一些指定的属性，除开一些必要的属性描述以外（我们可以在后面的生命周期看到，这些必要的属性是作为容器状态的一部分存在的），开发者可以大量定制自己想要的内容，比如通过Mount指定自己想要的挂载路径，用platform区分不同平台（Windows/linux/solaris/vm等）的特殊处理，以及丰富的HOOK内容，根据OCI的规定，提供的HOOK包含了开发者们启动环境前(preStart),创建环境前(createTuntime),创建容器前(createContainer)，启动容器前(startContainer)以及容器运行时根据返回结果或者退出时的情景(poststart和poststop)，能让开发者充分的干涉并组建自己需求的容器，不过runc实现的HOOK仅支持POSIX类的系统使用。这里我们使用runc生成一个官方示例的config.json,在make好的runc目录下执行命令即可：

```
runc spec
```

其中包含了ociVersion、root、hostname三个必填字段，以及process和mount这两个比较重要的非必输项

【图片】

在弄清楚容器静态的规范以后，我们还需要了解OCI中最重要的一部分：容器动态的规范，也就是OCI所规定的生命周期。首先，OCI规定容器的属性状态是一组要求包含以下内容：

- ociVersion：采用的oci版本
- id：容器的ID，单个主机上必须保持每个ID不同，复数主机上不做要求
- status：容器的状态，包括容器创建中(creating)，创建容器后但用户程序还未执行(created)，用户程序已执行(running)，容器停止(stopped)四种状态
- pid：用数字整形表示的容器ID，如果是在linux上，这个pid就是容器的进程ID
- bundle：表示之前文件系统根目录的绝对路径
- annotations：唯一一个非必需字段，包括一些和容器相关的注释

这里通过runc看到的容器状态如下：

【图片state】

我们也可以直接通过代码中的结构体看到具体的定义：

【图片containerState】

当然，在这之中最重要的还是status这个字段，如果是对Docker有接触的读者，看到这几个状态会颇感亲切，Docker的状态转化正是严格的遵循了OCI所定义的状态变化，同时去除了更细节化的created和creating区分，增加了pause这一状态来更好地服务开发人员。OCI定义的状态变换，和Docker状态变换基本类似，我们这里介绍具体OCI对容器的生命周期的定义，分为了13步，划分如此多步骤的原因是OCI对每一个HOOK使用的阶段和失败会导致的结果都做了严格的限定：

1. 在执行create命令之后，管理系统将会引用它的唯一标识和捆绑包的位置
2. 通过config.json创建容器需要的环境，如果创建失败，必须抛出失败异常并推出。此处OCI提到了多个“**必须**”，必须使用config.json文件来创建相关的环境，不得援引其它的文件；必须在这个步骤创建完成容器环境的状态；同时也绝对不能在这个步骤中运行用户程序。
3. prestart HOOK在运行时触发，如果失败了，必须抛出异常并跳转到步骤12，也就是销毁容器
4. createRuntime HOOK在运行时触发，如果失败了，必须抛出异常并跳转到步骤12，也就是销毁容器
5. createContainer HOOK在运行时触发，如果失败了，必须抛出异常并跳转到步骤12，也就是销毁容器 
6. 使用容器的唯一标识调用start命令
7. startContainer HOOK在运行时触发，如果失败了，必须抛出异常并跳转到步骤12，也就是销毁容器
8. 运行config.json中标注的process内容，也就是我们熟知的用户程序
9. poststart HOOK在运行时触发，如果失败了，只需要打印相关的错误日志，容器的生命周期和其它的HOOK仍然会继续执行
10. 容器退出，容器变成这种情况有可能时下列情景导致的：容器运行错误退出或者是管理系统的kill命令导致的
11. 使用容器的唯一标识调用delete命令
12. 必须销毁容器，方式需要遵循步骤2中的创建阶段
13. poststop HOOK在构建触发，如果失败了，只需要打印相关的错误日志，其它的HOOK仍然会继续执行


![状态转换](https://images2018.cnblogs.com/blog/952033/201805/952033-20180513150014145-179338855.png)

尽管看上去有很多的步骤，但去掉HOOK相关的描述，能看到容器基本的三态变化：created，running和stopped（我们也可以将其理解为exited）。而为了能让开发人员对容器状态进行自己想要的操作，所以OCI又做了以下要求：要求必须存在create/start/kill/delete/四种基本的命令。不难看出，我们在docker下执行的run命令，其实是完成了OCI中create/start两个命令的功能，而rm则完成了kill/delete两个命令的功能，对开发者来说，docker无疑是简化了相关的操作并使得其更易上手，但知晓其中构建的具体顺序有益我们理解背后开发者的设计思路。

【runcCommand图片】

可以看到runc除了基本的命令还提供了许多有益于维护的命令，比如listCommand等

