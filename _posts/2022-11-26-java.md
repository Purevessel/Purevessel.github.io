##
##jvm##
https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html

### java虚拟机： ###

编译(将java源码变为对应的虚拟机字节文件)——>java前端编译器转换输出class文件——>用java编译器执行字节码/JIT编译器转为机器代码后再执行

JIT编译器的虚拟机内又分为两种编译模式：一种直接转译为本地代码，另一种会进行较长的优化。一般会采用mixed的模式，即两种均采用的混合模式，可以用-Xint或者-Xcomp让所有代码都使用解释(Interpreted Mode)/编译（Compiled Mode）模式

另一种方式：AOT编译器，在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。

编译速度上，解释执行 > AOT 编译器 > JIT 编译器。

编译质量上，JIT 编译器 > AOT 编译器 > 解释执行。


文件结构：
[https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html](https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html "文件结构")

java的内存模型中，堆和方法区是共享的，但是有几项是线程私有的,exp:1.PC寄存器，用于存储当前线程执行的方法 2.虚拟机栈

### JVM类加载机制 ###

知晓了内存分布与编译转换的过程后，就需要将重点在于了解代码是如何转换并加载进内存的。从将字节码加载进内存到最后结束，大致可以分如下几步：加载->检验（可以视作静态检查，包括对规范，类型正确转换的检查）->准备->解析->初始化->运行->销毁

其中，准备和初始化的过程涉及到了对类的赋值和构造(面试常考),所以较为重要。

准备是指对JAVA中类变量(注意区分其与类成员变量的区别)的赋值，但此处赋值并非是程序员书写的赋值，而是由JAVA虚拟机赋值，比如初始化静态类变量的值地址为空:public static test = NULL，或者int类型赋为0等。但如果加入了修饰符final,表示赋值不再改变，因此会直接赋为书写的值

JAVA虚拟机并不会分辨何为构造函数的概念，它只是收集相关的赋值语句进行初始化。第一步，它会收集类变量(反复注意)和静态代码块的赋值；第二步，它会收集成员变量和普通代码块，以及最后执行的构造代码块。

触发初始化并不一定是严格按照上面的流程执行的，当有以下情况时，都会触发相关的初始化：

- new关键字实例化对象，读取/设置静态字段，调用静态方法
- 用reflect对某个类调用且该类未被初始化77
- 初始化某个类发现它的父类未初始化，需要初始化父类(注意不初始化它本身)
- 执行指定的main方法(即主类)，初始化主类
- 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。(照抄的，不懂)

## 堆空间 ##
为了保证程序运转内存的健康，了解了加载，就该了解JAVA虚拟机相关的回收机制。JAVA虚拟机有一套自己的垃圾回收机制，是基于一个很简单的思路进行的：即判断引用的计数是否变为0，相比C++运用智能指针(shared_ptr,还有用来解决循环引用的weak_ptr)，JAVA规定了GCRoot集，这个集合都是活跃的引用，只要对象的引用还有来自GCRoot的，它也必定是活跃的，这包括：

- 所有当前被加载的 Java 类
- Java 类的引用类型静态变量
- Java类的运行时常量池里的引用类型常量
- VM的一些静态数据结构里指向GC堆里的对象的引用
- 等等

标记清除算法：从名字可以看到其分为两个阶段：标记阶段和清除阶段。一种可行的实现方式是，在标记阶段，标记所有由 GC Root 触发的可达对象。此时，所有未被标记的对象就是垃圾对象。之后在清除阶段，清除所有未被标记的对象。标记清除算法最大的问题就是空间碎片问题。如果空间碎片过多，则会导致内存空间的不连续。虽说大对象也可以分配在不连续的空间中，但是效率要低于连续的内存空间。

复制算法：复制算法的核心思想是将原有的内存空间分为两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收。该算法的缺点是要将内存空间折半，极大地浪费了内存空间。

标记压缩算法：标记压缩算法可以说是标记清除算法的优化版，其同样需要经历两个阶段，分别是：标记结算、压缩阶段。在标记阶段，从 GC Root 引用集合触发去标记所有对象。在压缩阶段，其则是将所有存活的对象压缩在内存的一边，之后清理边界外的所有空间。

而JVM的回收机制专门根据了JVM的不同分区制定了不同的回收计划，老年代的分区由于使用对象使用时间长，所以直接采用复制算法回收肯定需要的空间开销极大，因此使用标记清除/标记压缩算法。而新生代分区中的对象数量较少，则可以直接使用复制算法。

JAVA的堆区是以新生代和老年代区分的，上面已经阐述过相关原则。而新生代中又有Eden区和Survivor区，Eden区占大部分内存空间的分配，因为它掌握大部分转瞬即逝的变量，时间比较长的则会送给Suvivor区。

回收类型与术语:

- minorGC 对新生代进行垃圾回收，比如Eden区分配空间满时就会触发
- majorGC 对老年代进行垃圾回收，由于往往是Eden区满后，一部分对象被回收，另一部分晋升到老年代，这时如果老年代空间也不足，就会触发majorGC。因此minorGC往往会触发majorGC
- fullGC 对所有的堆空间都进行垃圾回收，当准备要触发一次 Minor GC 时，如果发现年轻代的剩余空间比以往晋升的空间小，则不会触发 Minor GC 而是转为触发 Full GC。
- Stop-the-world ，是指在进行垃圾回收时因为标记或清理的需要，必须让所有执行任务的线程停止执行任务，从而让垃圾回收线程回收垃圾的时间间隔。在 Stop-The-World 这段时间里，所有非垃圾回收线程都无法工作，都暂停下来。只有等到垃圾回收线程工作完成才可以继续工作。

各种回收器：串行/并行/CMS/G1
 
## 1.7的永久代(Permanent Space)与1.8的元空间（MetaSpace） ##


jvm的处理场景：1.cpu长时间占用过高 2.高并发下的死锁 3.内存泄漏，gc时发现内存一直在变小

##
## 应付考试用 ##
