##
##jvm##
https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html

### java虚拟机： ###

编译(将java源码变为对应的虚拟机字节文件)——>java前端编译器转换输出class文件——>用java编译器执行字节码/JIT编译器转为机器代码后再执行

JIT编译器的虚拟机内又分为两种编译模式：一种直接转译为本地代码，另一种会进行较长的优化。一般会采用mixed的模式，即两种均采用的混合模式，可以用-Xint或者-Xcomp让所有代码都使用解释(Interpreted Mode)/编译（Compiled Mode）模式

另一种方式：AOT编译器，在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。

编译速度上，解释执行 > AOT 编译器 > JIT 编译器。

编译质量上，JIT 编译器 > AOT 编译器 > 解释执行。


文件结构：
[https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html](https://www.cnblogs.com/chanshuyi/p/jvm_serial_05_jvm_bytecode_analysis.html "文件结构")

java的内存模型中，堆和方法区是共享的，但是有几项是线程私有的,exp:1.PC寄存器，用于存储当前线程执行的方法 2.虚拟机栈

### JVM类加载机制 ###

知晓了内存分布与编译转换的过程后，就需要将重点在于了解代码是如何转换并加载进内存的。从将字节码加载进内存到最后结束，大致可以分如下几步：加载->检验（可以视作静态检查，包括对规范，类型正确转换的检查）->准备->解析->初始化->运行->销毁

其中，准备和初始化的过程涉及到了对类的赋值和构造(面试常考),所以较为重要。

准备是指对JAVA中类变量(注意区分其与类成员变量的区别)的赋值，但此处赋值并非是程序员书写的赋值，而是由JAVA虚拟机赋值，比如初始化静态类变量的值地址为空:public static test = NULL，或者int类型赋为0等。但如果加入了修饰符final,表示赋值不再改变，因此会直接赋为书写的值

JAVA虚拟机并不会分辨何为构造函数的概念，它只是收集相关的赋值语句进行初始化。第一步，它会收集类变量(反复注意)和静态代码块的赋值；第二步，它会收集成员变量和普通代码块，以及最后执行的构造代码块。

触发初始化并不一定是严格按照上面的流程执行的，当有以下情况时，都会触发相关的初始化：

- new关键字实例化对象，读取/设置静态字段，调用静态方法
- 用reflect对某个类调用且该类未被初始化77
- 初始化某个类发现它的父类未初始化，需要初始化父类(注意不初始化它本身)
- 执行指定的main方法(即主类)，初始化主类
- 当使用 JDK1.7 动态语言支持时，如果一个 java.lang.invoke.MethodHandle实例最后的解析结果 REF_getstatic,REF_putstatic,REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有进行初始化，则需要先出触发其初始化。(照抄的，不懂)

## 堆空间 ##
为了保证程序运转内存的健康，了解了加载，就该了解JAVA虚拟机相关的回收机制。JAVA虚拟机有一套自己的垃圾回收机制，是基于一个很简单的思路进行的：即判断引用的计数是否变为0，相比C++运用智能指针(shared_ptr,还有用来解决循环引用的weak_ptr)，JAVA规定了GCRoot集，这个集合都是活跃的引用，只要对象的引用还有来自GCRoot的，它也必定是活跃的，这包括：

- 所有当前被加载的 Java 类
- Java 类的引用类型静态变量
- Java类的运行时常量池里的引用类型常量
- VM的一些静态数据结构里指向GC堆里的对象的引用
- 等等

标记清除算法：从名字可以看到其分为两个阶段：标记阶段和清除阶段。一种可行的实现方式是，在标记阶段，标记所有由 GC Root 触发的可达对象。此时，所有未被标记的对象就是垃圾对象。之后在清除阶段，清除所有未被标记的对象。标记清除算法最大的问题就是空间碎片问题。如果空间碎片过多，则会导致内存空间的不连续。虽说大对象也可以分配在不连续的空间中，但是效率要低于连续的内存空间。

复制算法：复制算法的核心思想是将原有的内存空间分为两块，每次只使用一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中。之后清除正在使用的内存块中的所有对象，之后交换两个内存块的角色，完成垃圾回收。该算法的缺点是要将内存空间折半，极大地浪费了内存空间。

标记压缩算法：标记压缩算法可以说是标记清除算法的优化版，其同样需要经历两个阶段，分别是：标记结算、压缩阶段。在标记阶段，从 GC Root 引用集合触发去标记所有对象。在压缩阶段，其则是将所有存活的对象压缩在内存的一边，之后清理边界外的所有空间。

而JVM的回收机制专门根据了JVM的不同分区制定了不同的回收计划，老年代的分区由于使用对象使用时间长，所以直接采用复制算法回收肯定需要的空间开销极大，因此使用标记清除/标记压缩算法。而新生代分区中的对象数量较少，则可以直接使用复制算法。

JAVA的堆区是以新生代和老年代区分的，上面已经阐述过相关原则。而新生代中又有Eden区和Survivor区，Eden区占大部分内存空间的分配，因为它掌握大部分转瞬即逝的变量，时间比较长的则会送给Suvivor区。

回收类型与术语:

- minorGC 对新生代进行垃圾回收，比如Eden区分配空间满时就会触发
- majorGC 对老年代进行垃圾回收，由于往往是Eden区满后，一部分对象被回收，另一部分晋升到老年代，这时如果老年代空间也不足，就会触发majorGC。因此minorGC往往会触发majorGC
- fullGC 对所有的堆空间都进行垃圾回收，当准备要触发一次 Minor GC 时，如果发现年轻代的剩余空间比以往晋升的空间小，则不会触发 Minor GC 而是转为触发 Full GC。
- Stop-the-world ，是指在进行垃圾回收时因为标记或清理的需要，必须让所有执行任务的线程停止执行任务，从而让垃圾回收线程回收垃圾的时间间隔。在 Stop-The-World 这段时间里，所有非垃圾回收线程都无法工作，都暂停下来。只有等到垃圾回收线程工作完成才可以继续工作。

各种回收器：串行/并行/CMS/G1
 
## 1.7的永久代(Permanent Space)与1.8的元空间（MetaSpace） ##


jvm的处理场景：1.cpu长时间占用过高 2.高并发下的死锁 3.内存泄漏，gc时发现内存一直在变小

##
## 应付考试用 ##

###变量###
字节大小：int占4，char占2，long、double都是8

自动装箱：对于–128到127（默认是127）之间的值，Integer.valueOf(int i) 返回的是缓存的Integer对象。而大于的就不是了，会新建对象

而Integer对象和int比较的时候会自动拆箱，所以比较的是字节大小

String是不可变类，重新赋值后副本地址会指向开辟的另外一块堆内存，所以接口传值后即使重新赋值，原值不变。如果换成别的引用类型副本和原数据指向同一块堆内存，副本改变重新赋值相当于把同一块堆内存数据更改

(b+c)==MESSAGE 相当于 new String(b+c)==MESSAGE，所以一定会返回false 

数组命名时名称与[]可以随意排列，但声明的二维数组中第一个中括号中必须要有值

###类###

静态块：用static申明，JVM加载类时执行，仅执行一次 

构造块：类中直接用{}定义，每一次创建对象时执行 

执行顺序优先级：静态块>main()>构造块>构造方法 

访问权限：

public : 对所有类可见。使用对象：类、接口、变量、方法

protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类）

default (即默认）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。

private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类）

抽象类中一定有方法是抽象的，但不一定是所有方法都是抽象的

静态内部类、成员内部类、局部内部类、匿名内部类

初始化过程：
父类（静态成员变量-普通成员变量-父类构造方法）-子类（静态成员变量-普通成员变量-父类构造方法）

java重载的时候以参数个数和类型作为区分，方法名相同，返回类型可以相同也可以不同

java的包是用来组织文件的一种虚拟文件系统



###异常###
try finally块中，如果try有return而finally没有，则会按照 try块代码-finally块代码-return的顺序执行，如果try和finally块都有return，则会按照 try块代码-finally块代码-finally块return的顺序执行。这是java虚拟机底层编译逻辑决定的

try的形式有三种： try-catch try-finally try-catch-finally 但catch和finally语句不能同时省略

###序列化###
transient表示不能被序列化

序列化是用来解决当遇到网络传输对象的场景时，由于没有内存地址作为映射，为了解决如何直接传输对象而提出来的办法。也可以用来解决持久化存储的问题


###正则###
[ ] 里面是不重复的，所以[://] 等价于[:/] ，如果[ ]后面没有带+号的话，是不会贪婪匹配的

replaceAll()函数的第一个参数是一个正则表达式

###集合###
HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。HashMap的底层结构是一个数组，数组中的每一项是一条链表。故采用的是拉链法解决

HashMap的实例有俩个参数影响其性能： “初始容量” 和 装填因子

HashMap实现不同步，线程不安全，但HashTable线程安全

HashMap中的key-value都是存储在Entry中的

HashMap可以存null键和null值，不保证元素的顺序恒久不变，它的底层使用的是数组和链表，通过hashCode()方法和equals方法保证键的唯一性

###高并发###